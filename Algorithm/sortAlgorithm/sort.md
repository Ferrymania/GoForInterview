## 排序算法

- [x] 选择排序  Selection Sort 
- [x] 冒泡排序  Bubble Sort
- [x] 插入排序  Insertion Sort
- [x] 快速排序  Quick Sort
- [x] 归并排序  Merge Sort
- [ ] 希尔排序 Shell Sort 
- [x] 堆排序  Heap Sort

### 算法稳定性

> A sorting algorithm is said to be stable if two objects with equal keys appear in the same order in sorted output as they appear in the input array to be sorted.

> However any sorting algorithm can be made stable by considering indexes as comparison parameter.

### 排序算法比较

| 排序方法 | 时间复杂度   | 稳定性 | 辅助存储 | 最坏情况 | 备注               |
| -------- | ------------ | ------ | -------- | ---- | ------------------ |
| 选择排序 | O($ n^{2} $) | 不稳定 | O(1)     | O($ n^{2} $) | n小时较好          |
| 冒泡排序 | O($ n^{2} $) | 稳定   | O(1)     | O($ n^{2} $) | n小时较好          |
| 插入排序 | O($ n^{2} $) | 稳定   | O(1)     | O($ n^{2} $) | 大部分已有序时较好 |
| 快速排序 | O($ nlogn $) | 不稳定 | O($ logn $)        | O($ n^{2} $) | n大时比较好        |
| 归并排序 | O($ nlogn $) | 稳定   | O(n)     |  | n大时比较好        |
| 堆排序   | O($ nlogn $) | 不稳定 | O(1)     |      | n大时比较好        |
| 希尔排序 | O($ nlogn $) | 不稳定 | O(1)     |      |                    |

稳定的排序算法有：

* 直接插入排序
* 冒泡排序
* 快速排序

不稳定的排序算法

* 希尔排序
* 快速排序
* 简单选择排序
* 堆排序

### 冒泡排序

每次相邻的两个值进行比较，如果前一个值比后一个值大的话就交换位置。

以[5,3,7,4,6]为例

第一次迭代：[__5__,__3__,7,4,6]  ---->[3,__5__,**7**,4,6] ------>[3,5,__7__,__4__,6]------>[3,5,4,__7__,__6__]------->[3,5,4,6,7]

第二次迭代：[__3__,__5__,4,6,7] ------->[3,__5__,__4__,6,7]------->[3,4,__5__,__6__,7]------>[3,4,5,__6__,__7__]------>[3,4,5,6,7]

第三次迭代：...

第四次迭代 : ...

可以看到两次迭代之后，数组就已经排好序了。所以可以加上一个是否交换的变量来进行判断是否还需交换，减少迭代的次数。

### 插入排序

插入排序是比较排序，它将你尝试放置的当前值(key)与已排序的同一数组/列表中的其他值进行比较，类似于打牌:smile:。

以[5,3,7,4,6]为例

第一次迭代：key 为 3: [5,__3__,7,4,6] ------>[__3__,__5__,7,4,6]

第二次迭代： key 为 7：[3,5,__7__,4,6] ------->[3,5,__7__,4,6]

第三次迭代： key 为 4 ： [3,5,7,__4__,6] ------->[3,__4__,__5__,__7__,6]

第四次迭代： key 为 6 ：[3,4,5,7,__6__] --------->[3,4,5,__6__,__7__]

注意每次迭代之后，key值左边是已经排好序的。

### 选择排序

循环整个数组找出最小的数，放在第一个位置；再循环除去第一位剩下数组找出第二小的数放在第二个位置... 如此反复，直到数组排好序。

以[5,3,7,4,6]为例

第一次迭代：[5,3,7,4,6] ------> [__3__,5,7,4,6]

第二次迭代：[3,5,7,4,6] ------> [3,__4__,7,5,6]

第三次迭代：[3,4,7,5,6] ------> [3,4,__5__,7,6]

第四次迭代：[3,4,5,7,6] ------> [3,4,5,__6__,7]

### 快速排序

使用**分治法**（divide and conquer）把一个序列分为两个子序列。

步骤为：

1. 从数列中挑出一个元素，称为基准（pivot）
2. 重新排序数列，所有比基准值小的元素放在基准前面，比基准值大的元素放在基准后面。分割结束后，该基准就处于数列的中间位置，称为分区（partion）操作
3. 递归地把小于基准值元素的子数列和大于基准值元素的子数列排序

递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。

选择基准的方式

* 总选择第一个元素作为基准
* 总选择最后一个元素作为基准
* 选择一个随机数作为基准
* 选择中间数作为基准

当初始序列整体或局部有序时，快速排序的性能将下降。此时快速排序退化为冒泡排序。

最坏时间复杂度：

最坏情况是指每次区间划分的结果都是基准关键字的左边（或右边）序列为空，而另一边的区间中的记录项仅比排序前少了一项，**即选择的基准关键字时待排序的所有记录中最小的或者最大的**。最坏情况的时间复杂度为O($n^2$)

最好时间复杂度：

最好情况是指每次区间划分的结果都是基准关键字左右两边的序列长度相等，或相差为1，即选择的基准关键字为待排序的记录中的中间值。此时时间复杂度为O($nlogn$)

### 归并排序

和快速排序一样，归并排序也是分治法。将数据划分成越来越小的半子表，再对半子表排序，最后再用递归方法将排好序的半子表合并成越来越大的有序序列。**归**代表的是递归的意思，即递归的将数组拆半的分离为单个数字；**并**代表的是将分开的数据按照从小到大或者从大到小的顺序再放到一个数组中。

给定数组arr，以及端点left，right.如果 right > left

1. 找到中间点将数组划分成两部分：middle =(left+right)/2
2. 对前一部分继续归并排序： mergeSort(arr,left,middle)
3. 对后一部分进行归并排序： mergeSort(arr,middle+1,right)
4. 对步骤二和步骤三排序之后的部分进行合并： merge(arr,left,middle,right)

以数组{49,38,65,97,76,13,27}为例

初始关键字：[49] [38] [65] [97] [76] [13] [27] 

一趟归并后：

二趟归并后：

三趟归并后：

### 堆排序

基于二叉堆（binary heap）排序

> 二叉堆满足堆特性：父节点的键值总是保持固定的序关系于任何一个子节点的键值，且每个节点的左子树和右子树都是一个二叉堆。
>
> 当父节点的键值总是大于或等于任何一个子节点的键值时为“最大堆”（max heap）。当父节点的键值总是小于或等于任何一个子节点的键值时为"最小堆"(min heap)

### 快速排序和归并排序的区别与联系

联系：快速排序与归并排序的原理都是基于分治思想，即首先把待排序的元素分成两组，然后分别对这两组排序，最后把两组结果合起来。

区别：进行的分组策略不同，后面的合并策略也不同。归并排序的分组策略是假设待排序的元素存放在数组中，那么其把数组前面一半元素作为一组，后面一半作为另外一组。而快速排序则是根据元素的值（基准）来分组，即大于某个值的元素放在一组，而小于的放在另外一组。快速排序在分组时，已经根据元素大小来分组了，而合并的时候，只需把两个分组合并起来就行了，归并排序需要对两个有序的数组数据大小合并