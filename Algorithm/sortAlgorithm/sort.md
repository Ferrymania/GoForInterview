## 排序算法

- [x] 选择排序  Selection Sort 
- [x] 冒泡排序  Bubble Sort
- [x] 插入排序  Insertion Sort
- [x] 快速排序  Quick Sort
- [x] 归并排序  Merge Sort
- [ ] 希尔排序 Shell Sort 
- [x] 堆排序  Heap Sort

### 算法稳定性

> A sorting algorithm is said to be stable if two objects with equal keys appear in the same order in sorted output as they appear in the input array to be sorted.

> However any sorting algorithm can be made stable by considering indexes as comparison parameter.

### 排序算法比较

| 排序方法 | 时间复杂度   | 稳定性 | 辅助存储 |      | 备注               |
| -------- | ------------ | ------ | -------- | ---- | ------------------ |
| 选择排序 | O($ n^{2} $) | 不稳定 | O(1)     |      | n小时较好          |
| 冒泡排序 | O($ n^{2} $) | 稳定   | O(1)     |      | n小时较好          |
| 插入排序 | O($ n^{2} $) | 稳定   | O(1)     |      | 大部分已有序时较好 |
| 快速排序 | O($ nlogn $) | 不稳定 | O($ logn $)        |      | n大时比较好        |
| 归并排序 | O($ nlogn $) | 稳定   | O(n)     |      | n大时比较好        |
| 堆排序   | O($ nlogn $) | 不稳定 | O(1)     |      | n大时比较好        |
| 希尔排序 | O($ nlogn $) | 不稳定 | O(1)     |      |                    |

稳定的排序算法有：

* 直接插入排序
* 冒泡排序
* 快速排序

不稳定的排序算法

* 希尔排序
* 快速排序
* 简单选择排序
* 堆排序

### 冒泡排序

每次相邻的两个值进行比较，如果前一个值比后一个值大的话就交换位置。

以[5,3,7,4,6]为例

第一次迭代：[__5__,__3__,7,4,6]  ---->[3,__5__,**7**,4,6] ------>[3,5,__7__,__4__,6]------>[3,5,4,__7__,__6__]------->[3,5,4,6,7]

第二次迭代：[__3__,__5__,4,6,7] ------->[3,__5__,__4__,6,7]------->[3,4,__5__,__6__,7]------>[3,4,5,__6__,__7__]------>[3,4,5,6,7]

第三次迭代：...

第四次迭代 : ...

可以看到两次迭代之后，数组就已经排好序了。所以可以加上一个是否交换的变量来进行判断是否还需交换，减少迭代的次数。

### 插入排序

插入排序是比较排序，它将你尝试放置的当前值(key)与已排序的同一数组/列表中的其他值进行比较，类似于打牌:smile:。

以[5,3,7,4,6]为例

第一次迭代：key 为 3: [5,__3__,7,4,6] ------>[__3__,__5__,7,4,6]

第二次迭代： key 为 7：[3,5,__7__,4,6] ------->[3,5,__7__,4,6]

第三次迭代： key 为 4 ： [3,5,7,__4__,6] ------->[3,__4__,__5__,__7__,6]

第四次迭代： key 为 6 ：[3,4,5,7,__6__] --------->[3,4,5,__6__,__7__]

注意每次迭代之后，key值左边是已经排好序的。

### 选择排序

循环整个数组找出最小的数，放在第一个位置；再循环除去第一位剩下数组找出第二小的数放在第二个位置... 如此反复，直到数组排好序。

以[5,3,7,4,6]为例

第一次迭代：[5,3,7,4,6] ------> [__3__,5,7,4,6]

第二次迭代：[3,5,7,4,6] ------> [3,__4__,7,5,6]

第三次迭代：[3,4,7,5,6] ------> [3,4,__5__,7,6]

第四次迭代：[3,4,5,7,6] ------> [3,4,5,__6__,7]

### 快速排序

使用分治法（divide and conquer）把一个序列分为两个子序列。

步骤为：

1. 从数列中挑出一个元素，称为基准（pivot）
2. 重新排序数列，所有比基准值小的元素放在基准前面，比基准值大的元素放在基准后面。分割结束后，该基准就处于数列的中间位置，称为分割（partion）操作
3. 递归地把小于基准值元素的子数列和大于基准值元素的子数列排序

递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。

选择基准的方式

* 总选择第一个元素作为基准
* 总选择最后一个元素作为基准
* 选择一个随机数作为基准
* 选择中间数作为基准

### 归并排序

和快速排序一样，归并排序也是分治法。将数据划分成越来越小的半子表，再对半子表排序，最后再用递归方法将排好序的半子表合并成越来越大的有序序列。**归**代表的是递归的意思，即递归的将数组拆半的分离为单个数字；**并**代表的是将分开的数据按照从小到大或者从大到小的顺序再放到一个数组中。

给定数组arr，以及端点left，right.如果 right > left

1. 找到中间点将数组划分成两部分：middle =(left+right)/2
2. 对前一部分继续归并排序： mergeSort(arr,left,middle)
3. 对后一部分进行归并排序： mergeSort(arr,middle+1,right)
4. 对步骤二和步骤三排序之后的部分进行合并： merge(arr,left,middle,right)

以数组{49,38,65,97,76,13,27}为例

初始关键字：[49] [38] [65] [97] [76] [13] [27] 

一趟归并后：

二趟归并后：

三趟归并后：



### 堆排序

基于二叉堆（binary heap）排序

> 二叉堆满足堆特性：父节点的键值总是保持固定的序关系于任何一个子节点的键值，且每个节点的左子树和右子树都是一个二叉堆。
>
> 当父节点的键值总是大于或等于任何一个子节点的键值时为“最大堆”（max heap）。当父节点的键值总是小于或等于任何一个子节点的键值时为"最小堆"(min heap)

