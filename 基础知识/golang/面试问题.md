### new 和 make 的区别

### 变量的作用域和生存周期

### 变量逃逸

### 判断两个slice是否相同

### 常量声明

常量值必须是编译期可确定的字符、字符串、数字或布尔值。可指定常量类型、或有编译器通过初始化值推断，不支持C/C++数字类型后缀。

常量值也可以是某些编译器能计算出结果的表达式，如`unsafe.Sizeof`、`len`、`cap`等

``` go
import "unsafe"
const (
    ptrSize = unsafe.Sizeof(uintptr(0))
    strSize = len("hello world")
)
```

在常量组中如不指定类型和初始化值，则与上一行非空常量右值相同

### 通过iota实现枚举

``` go
const (
	x = iota  //0
    y		  //1
    z         //2
)
```

``` go
const (
	_ = iota //0
    KB = 1 << (10*iota)   //1 << (10*1)
    MB                    //1<<(10*2)
    GB                    //1<<(10 *3)
)
```

如中断iota自增，则必须显示恢复。且后续自增值按行序递增，而非C enum按上一取值递增

``` go
const (
	a = iota   //0
    b          //1
    c = 100    //100
    d          //101
    e = iota   //4
    f          //5
)
```

### 变量与常量的区别

不同于变量在运行期间分配存储内存（非优化状态），常量通常会被编译器在预处理阶段直接展开，作为指令数据使用。数字常量不会分配存储空间，无须像变量那样通过内存寻址来取值，因此无法获取地址。

``` go
package main

var x = 100
const y = 200

func main(){
	println(&x,x)
	println(&y,y)    //error can not take the address of y
}
```

### 引用类型

**引用类型包括slice、map、channel等类型**。除了分配内存外，它们还须初始化一系列属性，诸如指针，长度，甚至包括哈希分布、数据队列等。

### 位运算

| AND 按位与 都为1       | a & b  |      |
| ---------------------- | ------ | ---- |
| OR 按位或 至少一个     | a \| b |      |
| XOR 按位异或 只有一个1 | a ^ b  |      |
| NOT  按位取反          | ^a     |      |
| AND NOT  按位清除      | a&^b   |      |
| LEFT SHIFT 位左移      | a<<2   |      |
| RIGHT SHIFT 位右移     | a >> 2 |      |

### 指针

内存地址是内存中每个字节单元的唯一编号，而指针则是一个实体。指针会分配内存空间，相当于一个专门用来保存地址的整型变量。指针类型支持相等运算符，但不能做加减法运算和类型转换。如果两个指针指向同一地址，或都为nil，那么它们相等。可通过`unsafe.Pointer`将指针转换为`uintptr`后进行加减法运算，但可能会造成非法访问。

### for ...range

for... range支持字符串、数组、数组指针、切片、字典、通道类型，返回索引、键值数据。

| data type   | 1st value | 2nd value |
| ----------- | --------- | --------- |
| string      | index     | s[index]  |
| array/slice | key       | v[index]  |
| map         | key       | value     |
| channel     | element   |           |

range会复制目标数据。受影响的始数组，可改用数组指针或切片类型。

### 闭包（closure）

闭包是在其词法上下文中引用了自由变量的函数，或者说是函数和其引用的环境的组合体。

```go
package main

func test(x int) func() {
	println(&x)
	return func(){
		println(&x ,x)
	}
}
func main(){
	f := test(100)
	f()
}
/*
0xc00003e000
0xc00003e000 100
*/
```

因为闭包通过指针引用环境变量，那么可能会导致其生命周期延长，甚至被分配到堆内存。另外，还有所谓”延迟求值”的特性

``` go
func test() []func() {
	var s []func()
	for i:=0 ;i<2;i++ {
		s =append(s,func(){
			println(&i,i)
		})
	}
	return s
}
func main(){
	for _,f := range test(){
		f()
	}
}
/*
0xc00003e000 2
0xc00003e000 2
*/
```

上例因为for循环复用局部变量i,那么每次添加的匿名函数引用的自然是同一变量，单号执行这些函数时，它们读取的是环境变量i最后一次循环时的值，即2.可以通过每次用不用的环境变量或传参复制，让各自闭包环境各不相同。

### 数组

如果元素类型支持 “==、！=” 操作符，那么数组也支持此操作

``` go
	a :=[2]int{1,2}
	b :=[2]int{1,2}

	fmt.Println(a==b) //true
```

指针数组是指元素为指针类型的数组

数组指针是获取数组变量的地址

``` go
x ,y := 10,20
a := [...]*int{&x,&y}
p := &a
fmt.Printf("%T ,%v\n",a,a)  //[2]*int ,[0xc00000a0c0 0xc00000a0c8]
fmt.Printf("%T ,%v\n",p,p)  //*[2]*int ,&[0xc00000a0c0 0xc00000a0c8]
```

### 切片

``` go
type slice struct {
    array unsafe.Pointer
    len int
    cap int
}
```

``` go
var a []int  //a==nil
b := []int{} //b != nil
```

不支持比较操作，就算元素类型支持也不行，仅能判断是否为nil

可获取元素地址，但不能向数组那样直接用指针访问元素内容

``` go
s := []int{1,2,3,4,5}
p := &s
p0 := &s[0]
p1 := &s[1]
fmt.Println(p,p0,p1) //&[1 2 3 4 5] 0xc000070030 0xc000070038

(*p)[0] +=10  //*[]int 不支持索引操作，须先返回[]int对象
*p1 += 10     //直接用元素指针操作
fmt.Println(s)  //[11 12 3 4 5]
	
a := [5]int{1,2,3,4,5}
q := &a
q[0] +=100
fmt.Println(a) //[101 2 3 4 5]
```

切片只是很小的结构体对象，用来代替数组传参可避免复制开销。还有，make函数允许在运行期间动态指定数组长度，避开了数组类型必须使用编译器常量的限制。**并非所有时候都适合用切片代替数组，因为切片数组可能会在堆山分配内存。而且小数组在栈上拷贝的消耗也未必就比make代价大。**

`append`向切片尾部添加数据，返回新的切片对象。如果超出cap限制，则为新切片对象重新分配数组

* 是超出切片cap限制，而非底层数组长度限制，因为cap可小于数组长度
* 新分配数组长度是原cap的2倍，而非原数组的2倍（并非总是2倍，对于较大的切片，尝试扩容1/4）

``` go
s := make([]int,0,100)
s1 := s[:2:4]
s2 :=append(s1,1,2,3,4,5,6)
fmt.Printf("s1 :%p:%v\n",&s1[0],s1)  //s1 :0xc00007e000:[0 0]
fmt.Printf("s2 :%p:%v\n",&s2[0],s2)  //s2 :0xc0000760c0:[0 0 1 2 3 4 5 6]

fmt.Printf("s data:%v\n",s[:10]) //s data:[0 0 0 0 0 0 0 0 0 0]
fmt.Printf("s1 cap :%d  s2 cap: %d\n",cap(s1),cap(s2)) //s1 cap :4  s2 cap: 8
```

### map

不能对nil字典进行写操作，但能读

``` go
var m [string]int
m["a"] = 1 //error
```

运行时会对字典并发操作做出检测。如果某个任务正在对字典进行写操作，那么其他任务就不能对该字典执行并发操作（读，写、删除），否则会导致进程崩溃。

### struct

只有所有字段类型全部支持时，才可做相等操作。可使用指针直接操作结构字段，但不能是多级指针。

空结构（struct{}）是指没有字段的结构类型。比较特殊，因为无论是其自身，还是作为数组元素类型，其长度都为0。

``` go
var a struct{}
var b [100]struct{}

fmt.Println(unsafe.Sizeof(a),unsafe.Sizeof(b))  // 0 0
```

空结构可作为通道元素类型，用于事件通知。

``` go
exit := make(chan struct{})
go func() {
	fmt.Println("hello world")
	exit <- struct{}{}
}()
<-exit
fmt.Println("end.")
```

### method

如何选择方法的receiver类型

* 要修改实例状态，用*T
* 无须修改状态的小对象或固定值，建议用T
* 大对象建议用*T,以减少复制成本
* 引用类型、字符串、函数等指针包装对象，直接用T
* 若包含Mutex等同步字段，用*T，避免因复制造成锁操作无效
* 其他无法确定的情况，都用*T

method set 

* 类型T 方法集包含所有receiver T 方法
* 类型 * T方法集包含所有receiver T + T* 方法

### 接口

#### 执行机制

#### 类型转换

类型推断可将接口变量还原为原始类型，或用来判断是否实现了某个更具体的接口类型。