## OSI 

开放式系统互联参考模型(Open System Interconnection Reference Model)

|                               |                                                              |                                                              |
| ----------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 应用层（Application Layer）   | 提供为应用软件而设的接口，以设置与另一应用软件之间的通信     | 例如: HTTP，HTTPS，FTP，TELNET，SSH，SMTP，POP3.HTML.等      |
| 表达层（Presentation Layer）  | 把数据转换为能与接收者的系统格式兼容并适合传输的格式         |                                                              |
| 会话层（Session Layer）       | 负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接 |                                                              |
| 传输层（Transport Layer）     | 把传输表头（TH）加至数据以形成数据包。传输表头包含了所使用的协议等发送信息 | 例如TCP 、 UDP                                               |
| 网络层（Network Layer）       | 决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成分组。网络表头包含了网络数据 | 例如IP                                                       |
| 数据链路层（Data Link Layer） | 负责网络寻址、错误侦测和改错。当表头和表尾被加至数据包时，会形成帧。数据链表头（DLH）是包含了物理地址和错误侦测及改错的方法。数据链表尾（DLT）是一串指示数据包末端的字符串 | 例如以太网、无线局域网（Wi-Fi）和通用分组无线服务（GPRS）    |
| 物理层（Physical Layer）      | 在局部局域网上传送[数据帧](https://zh.wikipedia.org/wiki/数据帧)（data frame），它负责管理计算机通信设备和网络媒体之间的互通。 | 包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机接口卡等 |

## TCP/IP协议

|                                  |      |                        |
| -------------------------------- | ---- | ---------------------- |
| 应用层（application layer）      |      | HTTP、FTP、DNS         |
| 传输层（transport layer）        |      | TCP 、UDP、 RTP、 SCTP |
| 网络互连层（internet layer）     |      | IP                     |
| 网络连接层（Network link layer） |      | 以太网 WIFI            |

## TCP

传输控制协议（Transmission Control Protocol）

* 面向连接的、可靠的、基于字节流的传输层通信协议。
* 将应用层的数据流分割成报文段并发送给目标结点的TCP层
* 数据包有序号，对方收到则发送ACK确认，未收到则重传
* 使用校验和来检验数据在传输过程中是否有误

数据传输的可靠性保证：

* 使用序号，对收到的TCP报文段进行排序以及检测重复的数据
* 使用校验和检测报文段的错误，即无措传输
* 使用确认和计时器来检测和纠正丢包或延时
* 流控制（Flow Control）
* 拥塞控制（Congestion control）
* 丢包重传

### 连接创建（三次握手）

在连接创建过程中，许多参数要被初始化。一对终端同时初始化一个它们之间的连接是可能的。但通常是由以端打开一个套接字(socket)然后监听来自另一方的连接，这就是通常所指的被动打开（passive open）.服务端被动打开之后，客户端就能够创建主动打开（active open）

1. 客户端向服务端发送一个SYN来创建一个主动打开。客户端把这段连接的序号设定为随机数A
2. 服务端为这个合法的SYN回送一个SYN/ACK，ACK的确认码为A+1,SYN/ACK包本身又有一个随机产生的序号B
3. 最后，客户端再发送一个ACK,此时包的序号被设定为A+1,而ACK的确认码则为B+1.当服务端收到这个ACK的时候，就完成了三次握手，并进入连接创建状态。

### 重连机制

如果服务端接收到了客户端发送的SYN返回了SYN/ACK后客户端掉线了，没有接收到第三步中客户端回传的ACK。则这个连接处于一个中间状态。服务端会在一定时间内重发SYN/ACK。在Linux下，默认重试次数为5次。重试的间隔从1s开始每次都翻倍，5次的重试间隔为1s,2s,4s,8s,16s,总共31s，第五次发出后还要等32s才知道第五次也超时了,所以总共需要63s,TCP才会断开这个连接。

调整重连的参数

* tcp_synack_retries:减少重试次数
* tcp_max_syn_backlog:增大SYN连接数
* tcp_abort_on_overflow:决定超出能力时的行为

### 终止连接（四次挥手）

1. Client 发送一个FIN，用来关闭Client到server的数据传送，client进入FIN_WAIT_1状态
2. Server收到FIN后，发送一个ACK给client，确认序号为收到序号+1(与SYN相同，一个FIN占用一个序号)，server进入CLOSE_WAIT状态
3. Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态
4. Client收到FIN后，Client进入**TIME_WAIT**状态，接着发送一个ACK给Server,确认序号为收到序号+1,Server进入CLOSED状态，完成四次挥手

#### 为什么有TIME_WAIT状态

* 确保有足够的时间让对方收到ACK包
* 避免新旧连接混淆

#### 服务器出现大量CLOSE_WAIT状态的原因

对方关闭socket连接，我方忙于读或写，没有及时关闭连接

## UDP

用户数据报协议（User Datagram Protocol）是一个简单的面向数据报的通信协议

* 面向非连接
* 不维护连接状态，支持同时向多个客户端传输相同的消息
* 数据包报头只有8个字节，额外开销小
* 吞吐量只受限于数据生成速率、传输速率以及机器性能
* 尽最大努力交付，不保证可靠交付，不需维持复杂的连接状态表
* 面向报文，不对应用程序提交的报文信息进行拆分或者合并

### 应用

* 域名系统（DNS）：其中查询阶段必须快速，并且只包含单个请求，后跟单个回复数据包
* 动态主机配置协议（DHCP）：用于动态分配IP地址
* 路由信息协议（RIP）

### TCP vs UDP

|            | TCP          | UDP        |
| ---------- | ------------ | ---------- |
| 是否连接   | 面向连接     | 面向非连接 |
| 传输可靠性 | 可靠         | 不可靠的   |
| 有序性     | 有序         | 无序       |
| 速度       | 慢           | 快         |
| 量级       | 传输大量数据 | 少量数据   |

## HTTP

超文本传输协议（HyperText Transfer Protocol）是一种用于分布式、协作式和超媒体信息系统的应用层协议

* 支持客户/服务器模式
* 简单快速
* 灵活
* 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
* 无状态：无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给我们发送数据过来，但是，发送完，不会记录任何信息（Cookie和Session产生的原因）

Http请求和响应的信息相似，都包括：

* 一个请求/响应行
* 可选的请求头/响应头
* 一个空行（CRLF）
* 可选的消息体

### Http 请求

#### 组成

* 请求行（request line）:请求方法+空格+请求URL+空格+HTTP协议及版本+CRLF
* 请求头(headers)
* 空行
* 消息体(message body)

``` 
GET /hello.txt HTTP/1.1
User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3
Host: www.example.com
Accept-Language: en, mi
```

#### 请求方法

| 方法    | 描述                                                         |
| ------- | ------------------------------------------------------------ |
| GET     | 请求指定的页面信息，并返回实体主体。                         |
| HEAD    | 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头 |
| POST    | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 |
| PUT     | 从客户端向服务器传送的数据取代指定的文档的内容。             |
| DELETE  | 请求服务器删除指定的页面。                                   |
| CONNECT | HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。    |
| OPTIONS | 允许客户端查看服务器的性能。                                 |
| TRACE   | 回显服务器收到的请求，主要用于测试或诊断。                   |
| PATCH   | 是对 PUT 方法的补充，用来对已知资源进行局部更新 。           |

### Http 响应

#### 组成

* 状态行(status line)：HTTP版本+空格+状态码+空格+描述符+CRLF
* 头部(headers)
* 可选的消息体

``` 
HTTP/1.1 200 OK
Date: Mon, 27 Jul 2009 12:28:53 GMT
Server: Apache
Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
ETag: "34aa387-d-1568eb00"
Accept-Ranges: bytes
Content-Length: 51
Vary: Accept-Encoding
Content-Type: text/plain
Hello World! My payload includes a trailing CRLF.
```

#### 长短连接

* 对于http/1.0版本的时候，客户端与服务端完成一个请求响应之后，会将之前建立的TCP连接断开，下次请求的时候要重新建立TCP连接，这也称为**短连接**
* 对于http/1.1版本，客户端与服务端完成一次请求响应之后，允许不断开TCP连接，即为**长连接**。（长连接是指一次TCP连接允许多次HTTP会话，http永远都是一次请求/响应，会话结束，http本身不存在长连接）
  * 优点：当网站中有大量静态资源就可以开启长连接，就可以通过一次TCP连接发送
  * 缺点：当客户端请求一次之后不再请求，而服务器却开着长连接资源被占用着，会浪费资源

### 状态码

* 1xx:指示信息--表示请求已接受，继续处理
* 2xx：成功--表示请求已被成功接收
* 3xx：重定向，需要进一步的操作以完成请求
* 4xx：客户端错误，请求包含语法错误或无法完成请求
* 5xx：服务端错误，服务端在处理请求的过程中发生了错误

